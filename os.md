![](https://raw.githubusercontent.com/mozhongzhou/myPict_img/main/pic/image-20240616190427512.png)

# 1-2 章总览 Overview

## 1、操作系统的概念

充当 **计算机用户** 和 **计算机硬件** 之间的 **中介** 的 **程序**

## 2、计算机系统结构

**冯诺伊曼** 体系结构

1. 输入数据和程序的 **输入设备**
2. 记忆程序和数据的 **存储器** 但是现代计算器已经转化为以存储器为中心
3. 完成数据加工处理的 **运算器** arithmetic logic unit ALU 逻辑上讲冯诺依曼计算机是以运算器为中心的
4. 控制程序执行的 **控制器** control unit CU
5. 输出处理结果的 **输出设备**

连接五大子系统之间的方式 以前多采用 **分散连接** 为增加效率和灵活性 出现了 **总线**

## 3、中断处理

作用、优势:中断处理的优势包括

1. 提高系统的响应速度和效率
2. 允许系统同时处理多个任务，
3. 以及提供了一种有效的错误处理和系统管理机制。

- **中断向量（Interrupt Vector, IV）**：是指向中断服务例程（ISR）的指针。当发生中断时，系统会使用这个指针来找到并执行相应的中断处理代码。

- **中断向量表（Interrupt Vector Table, IVT）**：是存储中断向量的表格。它包含了系统中所有可能的中断和异常的处理**入口点**。当发生中断时，CPU 会根据中断类型到这个表中查找对应的中断向量。
- **中断服务例程（Interrupt Service Routine, ISR）**：也称为中断处理程序，是响应特定中断的代码。当相应的中断发生时，CPU 会执行这段代码来处理中断。

- **中断请求（Interrupt Request , IRQ）**：是从**硬件设备到 CPU** 的信号，表明设备需要 CPU 的注意。每个 IRQ 线路都被分配给了特定的设备，当设备需要 CPU 处理数据时，它会发送 IRQ。
- **软件生成的中断（Software Generated Interrupt, SGI）**：也称为软中断，是由**软件指令**产生的中断，而不是由硬件事件直接触发。软件可以使用这种机制来触发中断处理程序的执行，以处理特定的软件事件或条件。

## 4、计算机系统的保护措施

### 4.1、二态模式

- 内核态 系统程序执行时 处理机所处的状态 此时处理机可以执行所有指令，包括特权指令

- 用户态 用户程序执行时 处理机所处的状态 只能执行非特权指令

这种模式的设计是为了防止用户程序直接执行可能会影响系统稳定性的操作。

### 4.2、CPU 保护

- CPU 保护模式：物理内存地址不能直接被程序访问，程序内部的地址需要被转化为物理地址后再去访问 ；实模式 CPU 运行环境 16 位，保护模式 32 位
- CPU 保护是通过设置保护模式来实现的，它确保物理内存地址不能直接被程序访问。程序中使用的地址需要通过操作系统转化为物理地址后才能访问，这样可以防止程序直接操作物理内存，从而保护系统的内存不被非法访问。

### 4.3、特权指令

具有特殊权限的指令。这类指令只用于操作系统或其他系统软件
用于执行一些关键的系统操作，如内存管理、进程控制等

### 4.4、存储器保护

- 连续内存分配：Base+Limitation
  连续内存分配使用基址（Base）和界限（Limitation）来限制程序访问的内存范围，防止程序访问非法内存区域

- 页式内存管理：Valid/Invalid Bit
  页式内存管理通过设置有效/无效位（Valid/Invalid Bit）来控制对内存页的访问，只有标记为有效的页才能被访问，这样可以进一步提高内存的保护效果。

## 5.进程

进程。它是系统内的工作单元。程序是被动实体，进程是主动实体。

进程需要资源来完成其任务

CPU，memory，I/O ，files

Initialization data

- **CPU**：进程需要 CPU 时间来执行其指令。
- **内存**：进程需要内存空间来存储其代码、数据以及运行时的临时信息。
- **I/O 设备**：进程可能需要输入/输出设备来进行数据的输入输出操作。
- **文件**：进程可能需要访问文件系统中的文件来读取数据或者存储结果。
- **初始化数据**：进程启动时可能需要一些初始化数据，这些数据可以是配置信息、启动参数等。

OS Service & Structure

![image-20240620204714825](https://raw.githubusercontent.com/mozhongzhou/myPict_img/main/pic/image-20240620204714825.png)

## 6、OS Structure

1. Simple structure （简单结构）– MS-DOS

没有明确分离内核与用户空间 简单设计 用于早期计算机系统

2. More complex（整体式结构） – UNIX（ Monolithic Structure ）

整体式 所有系统和内核都紧密集成在一个大内核中

3. Layered（分层） – THE

将系统分为不同层次 每层只用下一层提供的功能 让操作系统更加模块化 便于理解和维护 可能引入额外开销

4. Microkernel （微内核）– Mach

将核心功能（进程管理 内存管理） 留在内核中 而将其他服务 （文件系统 网络通信）移至用户空间 提高灵活性安全性

5. loadable kernel modules (LKMs)（模块化）--- Solaris

支持可加载内核模块 允许不重启系统时动态增删功能 提高可拓展性

6. Hybrid structure（混合结构）--- Mac OS X ，iOS ，Android

结合 **微内核** 的优点和 **单内核** 的高性能

# 第三章 Process

## 1、进程概念：

进程是操作系统中的基本概念，它代表着操作系统中正在执行的程序。每个进程都是独立的执行单元，拥有自己的执行顺序和状态。进程的执行必须按照特定的顺序进行，这是由操作系统的调度策略决定的。

## 2、进程的组成部分：

进程由多个部分组成，包括：

- **Text**：程序的代码部分。
- **Data**：程序的全局变量和静态变量。
- **Stack**：程序的运行时栈，用于存储局部变量、函数参数等。
- **Heap**：动态分配的内存，如通过`malloc`或`new`分配的内存。
- **Register**：寄存器，存储当前执行的指令和其他关键信息。
- **PC（Program Counter）**：程序计数器，指向下一条要执行的指令。

## 3、进程的状态：

进程在其生命周期中会经历多种状态，包括：

- **New**：进程刚被创建。
- **Running**：进程正在 CPU 上执行。
- **Waiting**：进程等待某些事件发生，如 I/O 操作完成。
- **Ready**：进程准备好运行，等待被调度到 CPU 上。
- **Terminated 终止**：进程执行完毕或被终止。

![image-20240620212530689](https://raw.githubusercontent.com/mozhongzhou/myPict_img/main/pic/image-20240620212530689.png)

## 4、进程控制块（PCB）：

PCB 是操作系统中用于**存储进程信息**的数据结构，包括进程状态、程序计数器、CPU 寄存器、内存管理信息等。**PCB 是操作系统管理进程的关键数据结构。**

## 5、抢占性问题：

在多任务操作系统中，进程从一个状态转换到另一个状态可能涉及到抢占性问题，如从“等待”状态转换到“就绪”状态，或从“运行”状态转换到“就绪”状态。这涉及到操作系统的调度策略，如何公平、高效地分配 CPU 时间给多个进程。

## 6、进程调度：

进程调度是操作系统中的一个核心功能，负责管理进程的执行顺序。它涉及到几个关键组成部分：

- **就绪队列**：存放已准备好执行但正在等待 CPU 资源的进程。
- **等待队列**：存放因为等待某些事件（如 I/O 操作完成）而被挂起的进程。
- **上下文切换**：当操作系统从一个进程切换到另一个进程时，需要保存当前进程的状态（上下文）并加载新进程的状态，这个过程称为上下文切换。上下文切换是一个开销较大的操作，因为它涉及到 CPU 状态的保存与恢复。

## 7、进程间通信（IPC）：

进程间通信是指在不同进程之间交换数据的机制。它是多任务操作系统中实现进程协作的重要手段。共享内存是 IPC 的一种形式，它允许两个或多个进程访问同一块内存区域，从而实现数据的共享和交换。

1. **共享内存**：在共享内存模型中，操作系统会提供一块可以被多个进程访问的内存区域。这种方式的优点是数据交换速度快，因为数据不需要在进程间复制，只需要通过内存就可以直接访问。然而，这也带来了同步和数据一致性的挑战。
2. **生产者-消费者问题**：这是一个经典的并发问题，用于描述两个或多个进程间的协作模式。生产者进程负责生成数据并放入缓冲区，消费者进程则从缓冲区中取出数据进行处理。**这个问题的关键在于如何确保生产者不会在缓冲区满时向其写入数据，以及消费者不会在缓冲区空时尝试从中读取数据。**
3. **有界缓冲区与无界缓冲区**：
   - **有界缓冲区**：缓冲区的大小是固定的，这意味着它能够存储的数据量是有限的。在这种情况下，必须有机制确保当缓冲区满时生产者停止生产，当缓冲区空时消费者停止消费。
   - **无界缓冲区**：理论上缓冲区的大小是无限的，生产者可以无限制地生产数据，而不用担心缓冲区会溢出。然而，在实际应用中，无界缓冲区可能会因为资源限制（如内存大小）而不能真正实现无限制。

## 8、消息传递

1. **直接通信（Direct IPC）**：在这种模式下，每对进程都需要显式地发送消息给对方。**发送方需要指定接收方的标识符，而接收方需要从指定的发送方接收消息。**这种方式的通信是直接的，没有中间实体或存储介质参与消息的传递。
2. **间接通信（Indirect IPC）**：间接通信通过使用共享的数据结构（如消息队列）来实现，进程通过这些共享结构来交换消息。在这种模式下，发送方和接收方不需要直接知道对方的标识符，它们通过**操作共享的消息队列来进行通信。**
3. **管道（Pipes）**：
   - **普通管道（Unnamed Pipes）**：这是最简单的管道形式，通常用于有亲缘关系的进程间通信（如父子进程）。普通管道是**单向的**，数据只能从一端流向另一端。
   - **命名管道（Named Pipes）**：与普通管道不同，命名管道可以在没有亲缘关系的进程间进行通信。它们在**文件系统中有一个名字**，任何知道这个名字的进程都可以通过它来发送或接收数据。命名管道可以是**单向的或双向**的。
4. **套接字（Sockets）**：套接字是一种更为复杂和强大的通信机制，**它不仅可以用于同一台机器上的进程间通信，还可以用于不同机器上的进程间通信**。套接字支持多种通信协议（如 TCP 和 UDP），提供了丰富的接口来实现复杂的网络通信。

## 9、同步：

在多进程或多线程环境中，同步是确保数据一致性和避免竞态条件的机制。它可以分为两种：

- **阻塞同步**：进程在等待某个条件满足时被挂起，直到条件满足后才继续执行。
- **非阻塞同步（异步）**：进程在等待某个条件时不会被挂起，而是继续执行其他任务，条件满足后通过回调或事件来通知进程。

# 第四章 Thread&Concurrency

## **好处**：线程和并发编程带来了多方面的好处，包括：

- **响应性**：在多线程应用中，即使某个线程因为执行长时间操作而阻塞，其他线程仍然可以继续执行，从而提高了应用的响应性。
- **资源共享**：线程间可以共享进程资源，如内存和文件，这使得数据交换和通信更加方便。
- **经济**：相比于进程，线程的创建、销毁和切换的开销更小。
- **可扩展性**：多线程可以更好地利用多核处理器的计算能力，提高应用的性能。

## **并行类型**：并行编程可以分为两种类型：

- **数据并行性**：将数据分割成多个部分，由多个线程并行处理，每个线程处理数据的一个子集。
- **任务并行性**：程序被分成多个可以并行执行的任务，每个任务由一个线程执行。

## **多线程模型**：描述了用户线程和内核线程的关系，主要有三种模型：

- **多对一**：多个用户线程映射到一个内核线程。这种模型的缺点是一个用户线程阻塞会导致所有用户线程阻塞。
- **一对一**：每个用户线程对应一个内核线程。这提高了并发性，但创建大量线程时会增加开销。
- **多对多**：多个用户线程可以映射到多个内核线程。这种模型既提供了良好的并发性，又避免了一对一模型中的开销问题。

## **两级模型（M:M+1:1）**：

这是一种特殊的多对多模型，它允许系统动态调整用户线程和内核线程之间的映射关系，以达到最优的性能。这种模型结合了多对一和一对一模型的优点，提供了更高的灵活性和效率。

# 第五章 CPU Scheduling

1. **调度评价指标**：在评估 CPU 调度算法的效果时，通常会考虑以下几个关键指标：
   - **CPU 利用率**：衡量 CPU 活跃时间与总时间的比例，高 CPU 利用率意味着系统能高效利用 CPU 资源。
   - **吞吐量**：单位时间内完成的作业数量，反映了系统的处理能力。
   - **周转时间**：从作业提交到作业完成的总时间，包括等待、执行和 I/O 操作的时间。
   - **等待时间**：作业在就绪队列中等待被调度的时间总和。
   - **回答**：这可能是指对作业完成情况的反馈或评价。
2. **调度算法**：介绍了几种常见的 CPU 调度算法，包括：
   - **FCFS（先来先服务）**：按照作业到达的顺序进行调度。
   - **Shortest-Job-First（最短作业优先）**：优先调度预计执行时间最短的作业。
   - **Round Robin（时间片轮转）**：每个作业轮流使用 CPU 一定时间片，适用于时间共享系统。
   - **Priority Scheduling（优先级调度）**：根据作业的优先级进行调度。
   - **Priority+Round-Robin**：结合了优先级调度和时间片轮转的特点。
   - **Multilevel Queue（多级队列）**：根据作业的类型将其分配到不同的队列，每个队列有自己的调度算法

计算给定案例的等待时间

**产生优先级反转：SJF、多级队列**

Multi-Processor Scheduling

![image-20240620215717721](https://raw.githubusercontent.com/mozhongzhou/myPict_img/main/pic/image-20240620215717721.png)

Abstract

2 levels of scheduling

![image-20240620215737502](https://raw.githubusercontent.com/mozhongzhou/myPict_img/main/pic/image-20240620215737502.png)

# 第六章 Synchronization Tools

1. **并发共享资源访问的问题**：在多线程程序中，当多个线程同时访问同一资源时，如果没有适当的同步控制，就会导致数据的不一致性问题。
2. **临界区（Critical Section, CS）**：是指那些访问共享资源的代码区域。为了防止不一致性问题，需要对临界区进行访问控制。

![image-20240620225417275](https://raw.githubusercontent.com/mozhongzhou/myPict_img/main/pic/image-20240620225417275.png)

1. **解决临界区问题的三个条件**：
   - **互斥（Mutual Exclusion）**：任何时刻只允许一个线程进入临界区。
   - **前进性（Progress）**：如果没有线程在临界区内，那么在外部等待的线程必须能够进入临界区。
   - **有限等待（Bounded Waiting）**：确保等待进入临界区的线程最终能够进入。
2. **Peterson's Solution** 和 **Turn+Flag** 方法是解决临界区问题的经典算法，主要用于两个线程的同步。
3. **硬件同步机制**：包括内存屏障（Memory barriers）、硬件指令（如 Test-and-Set, Compare-and-Swap）和原子变量，这些机制可以直接由硬件支持，提高同步操作的效率。
4. **互斥锁（Mutex Locks）**：通过`acquire()`和`release()`操作来获取和释放锁，保证了临界区的互斥访问。
5. **信号量（Semaphore）**：是一种更为通用的同步机制，通过`wait()`和`signal()`操作来实现线程间的同步和通信。
6. **生产者-消费者（Producer-Consumer）** 和 **读者-写者（Reader-Writer）** 问题是并发编程中的经典问题，通过使用信号量或互斥锁可以有效地解决这些问题。

首先，展示了两个基础的同步原语：test_and_set 和 compare_and_swap。这两个函数是实现**低级同步机制**的基础，通常由硬件直接支持。

```cpp
boolean test_and_set (boolean *target)
        {
          boolean rv = *target;
          *target = true;
          return rv:
         }
test_and_set函数通过检查目标变量的值，然后将其设置为true，并返回原始值。这个操作是原子的，意味着在执行过程中不会被其他线程中断，常用于实现锁机制。
int compare_and_swap(int *value, int expected, int new_value) {
         int temp = *value;
          if (*value == expected)
            *value = new_value;
            return temp;      }
compare_and_swap函数则是比较目标变量的当前值与预期值，如果相同，则将其更新为新值。这个操作也是原子的，广泛用于实现更复杂的同步机制，如无锁数据结构。
```

接下来，介绍了信号量的概念，它是一种更高级的同步机制。信号量通过两个原子操作 wait()和 signal()来控制对共享资源的访问。wait()操作会递减信号量的值，如果信号量的值小于 0，则线程会阻塞直到信号量的值被其他线程通过 signal()操作增加。这个机制可以用来实现线程间的同步和互斥。

信号量 S-整数变量，仅通过两个原子操作访问

wait():递减，阻塞直到信号量打开(down())

signal():增量，允许另一个线程进入(up())

Consider P1 and P2 that requires S1 to happen before S2

Create a semaphore "synch" initialized to 0

```cpp
P1:
   S1;
   signal(synch);
P2:
   wait(synch);
   S2;`
```

文本中还提供了一个使用信号量同步两个线程的示例，其中 P1 线程执行操作 S1 后通过 signal()操作释放信号量，P2 线程则在执行操作 S2 之前通过 wait()操作等待信号量。这确保了 S1 操作在 S2 之前执行。

Reader -writer

Producer -Consumer

For reading
文本中还提供了一个使用信号量同步两个线程的示例，其中 P1 线程执行操作 S1 后通过 signal()操作释放信号量，P2 线程则在执行操作 S2 之前通过 wait()操作等待信号量。这确保了 S1 操作在 S2 之前执行。

最后，文本通过读者-写者和生产者-消费者问题展示了信号量在实际应用中的使用。读者-写者问题中，使用信号量来确保当有写者时，读者不能读取数据，反之亦然。生产者-消费者问题则是通过信号量来同步生产者和消费者之间的生产和消费操作，确保生产者不会在缓冲区满时写入数据，消费者也不会在缓冲区空时尝试读取数据。

这些机制和示例展示了在并发编程中同步和互斥的重要性，以及如何使用不同的同步工具来解决这些问题。

```cpp
while(1)
{
	P(&mutex);
	readcount++  ;
	if( readcount==1 ) P(&wrt);
	V(&mutex);
	Reading is performed;
	P(&mutex);
	Readcount-- ;
	if(readcount==0 )   V(&wrt);
	 V(&mutex);
}
```

For writing

# 第七章 Deadlocks

必要条件：

Mutual exclusion（互斥）

Hold and wait （持有并等待）

No preemption （无抢占）

Circular wait （循环等待）

处理死锁的方法

死锁预防：中断 必要条件

避免死锁

安全状态

单个实例：资源分配图

多个实例：银行家算法

死锁检测

单个实例：等待图
多个实例：检测算法

从死锁中恢复

# 第八章 Main Memory

逻辑地址空间 VS 物理地址空间

逻辑地址空间：程序生成的所有逻辑地址的集合

物理地址空间：程序生成的所有物理地址的集合

保护

一对基寄存器和极限寄存器定义进程的逻辑地址空间

连续内存分配

**First-fit** （首次分配）

**Best-fit** （最佳分配）

**Worst-fit** （最差分配）

**External Fragmentation** 、**Internal Fragmentation**（外部碎片，内部碎片）

**分页 （重点）**

page ，frame（页、帧）

用于将逻辑地址转换为物理地址的页表

内部碎片

![image-20240620232944442](https://raw.githubusercontent.com/mozhongzhou/myPict_img/main/pic/image-20240620232944442.png)

页表的结构

Hierarchical Paging（分层分页）

Hashed Page Tables（哈希页表）

Inverted Page Tables（倒排页表）

TLB and EAT calculation（TLB 和 EAT 计算）

# 第九章 Virtual Memory

优点

虚拟内存 – 将用户逻辑内存与物理内存分离

只有部分程序需要在内存中执行

逻辑地址空间可以比物理地址空间大得多

允许多个进程共享地址空间

允许更高效的流程创建

更多程序同时运行

加载或交换进程所需的 I/O 更少

虚拟内存可以通过以下方式实现：

需求分页

需求细分

需求分页

可以在加载时将整个进程放入内存或者只在需要时将页面放入内存

有效无效位

页面替换

页面故障

页面和帧替换算法

引用字符串

FIFO 算法、最优算法、 LRU 算法、LRU 近似算法

计算页面故障数

抖动

进程正忙于进出页面页面故障率高，CPU 利用率低

为了防止抖动：为进程提供所需数量的帧。

# 第十、十一章 File System

逻辑存储单元：文件

目录结构两个级别树

一级

二级

树

不带循环的图

文件共享和保护

权限（本地、共享）

访问控制

分层 FS 体系结构

逻辑 FS，文件组织模块，基本 FS

引导记录，分区控制块，FCB

目录实现：线性列表、哈希表

磁盘空间分配：连续分配、链接分配、索引分配
